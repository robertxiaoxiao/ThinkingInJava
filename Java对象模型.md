# Java对象模型

### 一 java对象生命周期

​	1  方法区中存放class的相关信息，比如类名，访问修饰符，常量池，字段描述，方法描述。

​	2  java堆存放对象的实例。

​	方法区和堆都是为所有线程所共享。

### 二 对象的创建过程

1.  类加载过程

2. 分配内存

   - 指针碰撞     线程不安全
   - 维护堆内存的空闲列表
   - 本地线程分配缓冲

    每个线程在堆中预先分配一小块内存，当TLAB用完时才需要同步锁定进行分配。

3. 初始化

   将分配到的内存空间都初始化为零值，对对象进行设置，（哪个类的实例，如何找到类的元数据休息，对象的哈希码，对象的GC分代年龄，是否启用偏向锁），相关信息都存储在对象头的内存中。

4 对象的内存布局

  对象在内存中分三部分，对象头，实例数据，对齐填充。

![img](https://images2015.cnblogs.com/blog/568153/201707/568153-20170710131157259-132221985.png)

- 对象头

  （1）存储自身运行数据（hashcode,gc,lockstate,timestamp）

  （2）类型指针，对象指向它的类元数据的指针，如果对象是数组，对象头中必须有记录长度的数据。

- 实例数据

- 对齐填充

### 三 对象的访问定位

​	对象的访问定位也取决于具体的虚拟机实现。当我们在堆上创建一个对象实例后，就要通过虚拟机栈中的reference类型数据来操作堆上的对象。现在主流的访问方式有两种（HotSpot虚拟机采用的是第二种）：

1. 使用句柄访问对象。即reference中存储的是对象句柄的地址，而句柄中包含了对象实例数据与类型数据的具体地址信息，相当于二级指针。
2. 直接指针访问对象。即reference中存储的就是对象地址，相当于一级指针**。**

　　两种方式有各自的优缺点。当垃圾回收移动对象时，对于方式一而言，reference中存储的地址是稳定的地址，不需要修改，仅需要修改对象句柄的地址；而对于方式二，则需要修改reference中存储的地址。从访问效率上看，方式二优于方式一，因为方式二只进行了一次指针定位，节省了时间开销，而这也是HotSpot采用的实现方式。下图是句柄访问与指针访问的示意图。

![img](https://images2015.cnblogs.com/blog/616953/201602/616953-20160226155344349-887482013.png)

![img](https://images2015.cnblogs.com/blog/616953/201605/616953-20160518141733169-1486000631.png)

